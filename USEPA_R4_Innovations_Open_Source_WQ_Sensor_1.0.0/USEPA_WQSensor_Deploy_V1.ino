/* ******************************************************************************************************************************************************************************
 *  This Arduino sketch was created to program and evaluate an open-source water quality sensor system designed for the US EPA Region 4 Regional/State Innovations Project Titled
 *  "Low-Cost Sensors for Real-Time Continuous Water Quality Monitoring." 
 *  For more information pertaining to this project please visit: https://www.epa.gov/innovation/low-cost-sensors-real-time-continuous-water-quality-monitoring
 *  This program is intended to be compatible with the specific sensor design used in this project and may be incompatible with other water quality sensors with different design
 *  parameters and hardware. A description of hardware used and general sensor design is included at the end of this sketch. This program as well as the water quality sensor
 *  design described within are based on open-source technology and associated resources specific to the technology used such as example programming available through hardware 
 *  manufacturers (e.g. Arduino, Atlas-Scientific, Adafruit Industries, etc). This program and associated water quality sensor design is in the public domain and may be freely 
 *  replicated or modified.
 *  
 *  Version: USEPA_WQSensor_Deploy_V1.ino     (Most recent version can be accessed at https://github.com/CWQM)
 *  
 *  Project Contacts: Nathan Barlet USEPA SESD (Barlet.Nathan@epa.gov)
 *                    Derek Little  USEPA SESD (Little.Derek@epa.gov)
 *  
 *  Created 22 Jan 2018 by Nathan Barlet (USEPA) 
 * ******************************************************************************************************************************************************************************/
/*##############################################################################################################################################################################
 * ############################################################################################################################################################################*/
 
 // These variables can be modified by the user:
 
char filename[]= "Test00.TXT";              //<-------Input File Name HERE!!! (ex. Test00.TXT) Use 4 character site name (ex. "AA01" or "AAAA") and always end in "00.TXT"
#define Write_API_Key "WXN86YPGT1ACQ0U1"    //<-------Input ThingSpeak Write_API Key key here inside the quotations!!! This is generated by ThingSpeak and specific to your channel!
                                            // Write_API_Key Example: "WXN86YPGT1ACQ0U1"
#define APN "m2mglobal"                     //<-------Use netowrk APN given by service provider through cellular data plan (ex. "m2mglobal")
int Sample_incr = 900;                      // Log interval in seconds, eg 300 for 5min, 900 for 15min, 1800 for 30 min, etc.
char Baro[] = "99";                         // Input average air pressure of monitoring site in kPa (this is for pressure corrections for dissolved oxygen measurements)
                                            // Visit http://www.altitude.org/air_pressure.php to convert site elevation into air pressure

/*################################################################################################################################################################################
 * ##############################################################################################################################################################################*/

// Call Libraries
#include "Adafruit_FONA.h"                  // supports communications with SIM808 chip on FONA808 2G modem shield from Adafruit
#include <Wire.h>                           // supports I2C communications
#include <SoftwareSerial.h>                 // supports software serial communications on digital pins
#include "RTClib.h"                         // supports the real time clock on the Data Logger shield from Adafruit
#include "SD.h"                             // supports the SD read/write functions on Adafruit Data Logger shield from Adafruit
#include <SPI.h>                            // Enables the SPI bus communication on MISO, MOSI, SCK pins on Adafruit Data Logger shield
#include <avr/sleep.h>                      // Supports sleep configurations between logging cycle
#include <avr/power.h>                      // Supports power configurations during sleep cycle
#include <avr/wdt.h>                        // Supports watchdog timer configurations

// Define Constants
RTC_PCF8523 rtc;                            // Define real time clock model used on Adafruit Data Logger shield
#define rtdaddress 111                      // I2C ID number for EZO RTD Circuit
#define ecaddress 112                       // I2C ID number for EZO EC Circuit
#define pHaddress 113                       // I2C ID number for EZO pH Circuit
#define doaddress 114                       // I2C ID number for EZO DO Circuit
#define batt_pin A5                         // Defines analog pin for reading the battery voltage from the external LiPo battery pack
#define ADC_AREF 5.0                        // Boosted operating voltage for the Arduino is 5V and is used for the reference voltage to calculate battery voltage

const int SDA_pin = 43;                     // Logic pin for enabling/disabling I2C coms to the Tentacle Shield on the SDA wire
const int SCL_pin = 39;                     // Logic pin for enabling/disabling I2C coms to the Tentacle Shield on the SCL wire
const int Atlas_pin = 44;                   // Logic pin that controls base pin on NPN-type transistor that switches Tentacle Shield ground wire ON/OFF
const int FONA_key = 24;                    // Logic pin to switch power to FONA808 Shield via the Key power function described in the product manual from Adafruit
const int chipSelect = 34;                  // Corresponds to chipselect pin required for SD card read/write functions on Data Logger Shield from Adafruit
volatile bool watchdogActivated = false;    // Flag for watchdog interrupt during sleep cycle

// Define Other Variables
byte code=0;                                // used to hold the I2C response code. 
byte in_char=0;                             // used as a 1 byte buffer to store in bound bytes from Atlas Scientific circuits   
byte i=0;                                   // counter used for Atlas Scientific data array 
char rtd_data[20];                          // A 20 byte character array to hold incoming data from the temperature circuit
char ph_data[20];                           // A 20 byte character array to hold incoming data from the pH circuit 
char ec_data[48];                           // A 48 byte character array to hold incoming data from the conductivity circuit
char do_data[48];                           // A 48 byte character array to hold incoming data from the dissolved oxygen circuit 
char *ec;                                   // char pointer used in string parsing for seperating conductivity and salinity data
char *sal;                                  // char pointer used in string parsing for seperating conductivity and salinity data
char *do_per;                               // char pointer used in string parsing for DO percent parameter
char *do_mg;                                // char pointer used in string parsing for DO mg/L parameter
uint16_t batt_read;                         // reads voltage level on analog pin corresponding to external battery voltage input
int mv;                                     // external battery voltage
uint16_t statuscode;                        // status return code for telemetry data upload
int16_t length;                             // length of character string of uploaded data
char url[300];                              // empty character array for data upload
String urldata = "https://api.thingspeak.com/update?api_key=";    // URL prefix required for data upload to ThingSpeak

DateTime tyme;                              // a working variable to handle times
DateTime nextlog;                           // the next time to log 
File dataFile;                              // data file variable for writing to SD card

boolean debug = true;

// Define FONA Variables
#define FONA_RX 2                           // this is TX from the Mega's pesrspective
#define FONA_TX 10                          // this is RX from the Mega's pesrspective
#define FONA_RST 4
char replybuffer[255];
Adafruit_FONA fona = Adafruit_FONA(FONA_RST);
uint8_t readline(char *buff, uint8_t maxbuff, uint16_t timeout = 0);
SoftwareSerial fonaSS = SoftwareSerial(FONA_TX, FONA_RX);
SoftwareSerial *fonaSerial = &fonaSS;
unsigned int uploadFailed = 0;
unsigned int fonaRTN = 9;
uint8_t type;

// Define watchdog timer interrupt.
ISR(WDT_vect)
{
  watchdogActivated = true;
}

/* Start Main Setup Subroutine #################################################################################################################*/
void setup() {
  // Open Serial Line
  Serial.begin(9600);
  // Set digital pins as outputs and turn on peripherals for setup and initialization
  
  // Inilialize RTC and Set Current Timestamp
  rtc.begin();  // start the real time clock
  if (! rtc.begin()) {
   Serial.println("Couldn't find RTC");
   while (1);
  }
  if (! rtc.initialized()) {
    Serial.println("RTC is NOT running!");
    // following line sets the RTC to the date & time this sketch was compiled
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    // This line sets the RTC with an explicit date & time, for example to set
    // January 21, 2014 at 3am you would call:
    // rtc.adjust(DateTime(2018, 1, 12, 8, 24, 0));
  }
  rtc.begin();  //start the real time clock
  tyme = rtc.now(); //recall time from the real time clock

  // Display initial timestamp on serial monitor if in debugging mode
  if (debug){
   Serial.println();
    Serial.print(tyme.year(), DEC);
    Serial.print('/');
    if(tyme.month() < 10){
      Serial.print('0');
      Serial.print(tyme.month(), DEC);}
    else {Serial.print(tyme.month(), DEC);}
    Serial.print('/');
    if (tyme.day() < 10){
      Serial.print('0');
      Serial.print(tyme.day(), DEC);}    
    else {Serial.print(tyme.day(), DEC);}
    Serial.print(',');
    if (tyme.hour() < 10){  
      Serial.print('0');
      Serial.print(tyme.hour(), DEC);}
    else {Serial.print(tyme.hour(), DEC);} 
    Serial.print(':');
    if (tyme.minute() < 10){
      Serial.print('0');
      Serial.print(tyme.minute(), DEC);}
    else {Serial.print(tyme.minute(), DEC);}
    Serial.print(':');
    if (tyme.second() < 10){
      Serial.print('0');
      Serial.print(tyme.second(), DEC);}
    else {Serial.print(tyme.second(), DEC);} // end of current time display}
    delay(200);
  }

  // Configure Arduino pins:
  pinMode(FONA_key, OUTPUT);      // Set digital pin as output to control key power switch on FONA shield
  digitalWrite(FONA_key, HIGH);   // Set pin high to turn on FONA shield
  pinMode(Atlas_pin, OUTPUT);     // Set digital pin as output to control logic pin to NPN-type transistor used to switch power to the Tentacle shield
  digitalWrite(Atlas_pin, HIGH);  // Set digital pin high to enable power to Tentacle shield
  delay(500);
  pinMode(SDA_pin, OUTPUT);       // Set digital pin as output to control logic pin to enable communications on SDA wire leading to Tentacle shield
  pinMode(SCL_pin, OUTPUT);       // Set digital pin as output to control logic pin to enable communications on SCL wire leading to Tentacle shield
  digitalWrite(SDA_pin, HIGH);    // Set digital pin high to enable Tentacle shield SDA wire
  digitalWrite(SCL_pin, HIGH);    // Set digital pin high to enable Tentacle shield SCL wire
  delay(200);

  // Inilialize SD Card and Setup File for Logging
  if (debug){
  Serial.println("Initializing SD card...");
  }

  pinMode(SS, OUTPUT);  // Required to configure SD card reader/writer
 
  // see if the card is present and can be initialized:
  if (!SD.begin(chipSelect)) {
  Serial.println("Card failed, or not present");
    // don't do anything more...unable to save data to SD card
    while (1) ;
  }
  
 if(debug){
  Serial.println("card initialized.");
 }
 
  // Name and open the file we're going to log to!
  Serial.println("card initialized.");
  // Open up the file we're going to log to!
  for (uint8_t i = 0; i < 100; i++) {
    filename[4] = i/10 +'0';
    filename[5] = i%10 +'0';
    if (! SD.exists(filename)) {
      // Only open a new file if it doesn't exist
      dataFile = SD.open(filename, FILE_WRITE);
      break; // leave the loop!
    }
  }

  // Check to see if the data file was opened correctly
  if (! dataFile) {
    Serial.println("error opening data file");
    // Wait forever since we cant write data
    while (1) ;
  }

  // Write the file name and data header to beginning of file
  if(debug){
    Serial.print("Logging to: ");
    Serial.print(filename);
    Serial.println(" ");
  }
  
  dataFile.print("Filename: ");
  dataFile.println(filename);
  dataFile.println(" ");
  dataFile.println("Date[y/m/d],Time[h:m:s],Temp[deg.C],pH[S.U.],SpCond[uS/cm],DO[mg/L],DO[%Sat],Batt[mv]");

  delay(200);

  // Enable required parameters for Atlas Scientific probes
  Wire.begin(); //enable I2C port.
  delay(500);
  
  Wire.beginTransmission(ecaddress);  // Call the address to the conductivity circuit
  Wire.write("O,TDS,0");  // Disable the total dissolved solids parameter as an output
  Wire.endTransmission(); 
  delay(500);
  
  Wire.beginTransmission(ecaddress);  
  Wire.write("O,S,1");    // Enable the salinity parameter in units ppt as an output
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(ecaddress);
  Wire.write("O,SG,0");   // Disable the specific gravity parameter as an output
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(doaddress);    // Call the address to the DO circuit
  Wire.write("O,%,1");    // Enable the percent DO parameter as an output
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(doaddress);
  Wire.write("O,mg,1");   // Enable the mg/L DO parameter as an output
  Wire.endTransmission();
  delay(500);

  // Disable LEDs on Atlas Stamps to save power during measurement subroutine
  Wire.beginTransmission(rtdaddress);   // Call address to temperature circuit
  Wire.write("L,0");    // Disable LED on Temperature circuit
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(pHaddress);    // Call address to pH circuit
  Wire.write("L,0");    // Disable LED on pH circuit
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(ecaddress);    // Call address to conductivity circuit
  Wire.write("L,0");    // Disable LED on conductivity circuit
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(doaddress);    // Call address to dissolved oxygen circuit
  Wire.write("L,0");    // Disable LED on dissolved oxygen circuit
  Wire.endTransmission();
  delay(500);

  Wire.beginTransmission(doaddress);    // Call address to dissolved oxygen circuit
  Wire.write("P,");                     // Issue command for pressure compensation
  Wire.write(Baro);                     // Input air pressure specific to monitoring site
  Wire.endTransmission();
  delay(500);
  
  // Enable sleep mode in probe circuits
  Wire.beginTransmission(rtdaddress);   // Call address to temperature circuit
  Wire.write("Sleep");    // Put temperature circuit into sleep mode
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(ecaddress);  // Call address to conductivity circuit
  Wire.write("Sleep");    // Put conductivity circuit into sleep mode
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(pHaddress);    // Call address to pH circuit
  Wire.write("Sleep");    // Put pH circuit into sleep mode
  Wire.endTransmission();
  delay(500);
  
  Wire.beginTransmission(doaddress);    // Call address to dissolved oxygen circuit
  Wire.write("Sleep");    // Put dissolved oxygen circuit into sleep mode
  Wire.endTransmission();
  delay(500);
  
  digitalWrite(SDA_pin, LOW);     // Set digital pin low to disable Tentacle shield SDA wire
  digitalWrite(SCL_pin, LOW);     // Set digital pin low to disable Tentacle shield SCL wire
  delay(200);
  digitalWrite(Atlas_pin, LOW);   // Set digital pin low to disable power to Tentacle shield
  delay(500);

  // Inilialize FONA
  if(debug){
  Serial.println(F("FONA basic test"));
  Serial.println(F("Initializing....(May take 3 seconds)"));
  }

  // Begin serial communications with FONA808 shield and power on
  fonaSerial->begin(4800);
  if (! fona.begin(*fonaSerial)) {
    if(debug){
      Serial.println(F("Couldn't find FONA"));
      Serial.println(F("Switching Power for Second Attempt..."));
    }
    digitalWrite(FONA_key, LOW);    // If FONA was set in off state in last log interval, the device needs to be turned on by pulling the key pin low for 2 seconds
    delay(2000);
    digitalWrite(FONA_key, HIGH);   // After the key pin is pulled low return to the high state, consult FONA808 manual from Adafruit Industries for more detail
    delay(500);
    if (! fona.begin(*fonaSerial)) {
      Serial.println(F("Still No FONA..."));
      while(1);
    }
  }

  // Determine type/model/version of FONA in use
  type = fona.type();
  Serial.println(F("FONA is OK"));
  Serial.print(F("Found "));
  switch (type) {
    case FONA800L:
      Serial.println(F("FONA 800L")); break;
    case FONA800H:
      Serial.println(F("FONA 800H")); break;
    case FONA808_V1:
      Serial.println(F("FONA 808 (v1)")); break;
    case FONA808_V2:
      Serial.println(F("FONA 808 (v2)")); break;
    case FONA3G_A:
      Serial.println(F("FONA 3G (American)")); break;
    case FONA3G_E:
      Serial.println(F("FONA 3G (European)")); break;
    default: 
      Serial.println(F("???")); break;
  }

  // Print module IMEI number.
  char imei[16] = {0}; // MUST use a 16 character buffer for IMEI!
  uint8_t imeiLen = fona.getIMEI(imei);
  if (imeiLen > 0) {
    Serial.print("Module IMEI: "); Serial.println(imei);
  }
  // Print FONA battery voltage:
  Serial.println("Reading FONA battery status...");
  FONA_battery();
  
  // Print signal stength (RSSI):
  Serial.println("Reading FONA signal strength...");
  Read_RSSI();
  delay(10000); // Give FONA time to search for network
  
  // Print FONA network status:
  Serial.println("Reading FONA network status...");
  network_status();
  fona.setGPRSNetworkSettings(F(APN));

  // Power down FONA shield until data upload routine
  digitalWrite(FONA_key, LOW);
  delay(2000);
  digitalWrite(FONA_key, HIGH);
  delay(200);

  // Read Current Timestamp and Set Next Log Time
  rtc.begin();  //start the real time clock
  tyme = rtc.now(); //recall time from the real time clock
  nextlog = tyme.unixtime()/Sample_incr*Sample_incr+Sample_incr;    // rounds next log time off to an even time (e.g. 15 min intervals on the quarter hour)
  Serial.println("Setup complete.");
  delay(200);

  // Setup Watchdog Timer as interrupt for Sleep Mode
  wdt_setup_interrupt();
} /* END of Main Setup Routine ################################################################################################################*/

/* Start Main Loop Subroutine #################################################################################################################*/
void loop() { // This is the main loop routine that moves the program through the data logging, data upload, and sleep cycles
  if (watchdogActivated){
    watchdogActivated = false;    // resets the watchdog timer flag
    Serial.begin(9600);   // Open serial coms at 9600 baud rate
    rtc.begin();  //start the real time clock
    tyme = rtc.now(); //recall time from the real time clock
    if (tyme.unixtime() >= nextlog.unixtime()) {  // Wake up and begin data logging and upload modes when next log interval is reached
      wdt_setup_reset();  // Set up watchdog timer as a system reset for system hangups
      if(debug){Serial.println("AWAKE and LOGGING!!!");   // print to serial monitor during debugging mode
        delay(200);}
      logmode();    // Go to data logging subroutine
      wdt_reset();  // reset watchdog timer
      if(debug){Serial.println("Uploading Data...");      // print to serial monitor during debugging mode
        delay(200);}
      Upload_Data();  // Go to data upload subroutine
      wdt_reset();    // reset watchdog timer
      if(debug){Serial.println("Log and Upload Cycle Complete...");   // print to serial monitor during debugging mode
        delay(200);}
      wdt_setup_interrupt();  // Setup watchdog timer as interrupt in sleep mode
    }
    else {    // The next logtime has not been reached yet
      if(debug){Serial.println("tyme < nextlog");
        delay(200);}
    }
  }
  // Go to sleep!
  if(debug){Serial.println("Getting Sleepy...");
    delay(200);}
  sleep();    // Go to sleep mode subroutine
}   /* END of Main subroutine #################################################################################################################*/

/* Start of Sleep Mode Subroutine #############################################################################################################*/
void sleep() {
  // Set sleep to full power down.  Only external interrupts or 
  // the watchdog timer can wake the CPU!
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);

  // Turn off the ADC while asleep.
  power_all_disable();

  // Enable sleep and enter sleep mode.
  sleep_mode();

  // CPU is now asleep and program execution completely halts!
  // Once awake, execution will resume at this point, this happens every 8 seconds when interrupted by watchdog timer to check the time relative to the next log time.
  
  // When awake, disable sleep mode and turn on all devices.
  sleep_disable();
  power_all_enable();
}
/* END of Sleep Mode Subroutine ##############################################################################################################*/

/* Start of FONA Battery Voltage Subroutine ##################################################################################################*/
void FONA_battery(){
  uint16_t vbat;    // define variable for FONA battery voltage
  if (! fona.getBattVoltage(&vbat)) {   // Reads FONA battery voltage in milli Volts using Adafruit_fona library
    Serial.println(F("Failed to read Batt"));
  } else {
    Serial.print(F("VBat = ")); Serial.print(vbat); Serial.println(F(" mV"));
  }
  if (! fona.getBattPercent(&vbat)) {   // Reads FONA battery voltage in percentage using Adafruit_fona library
    Serial.println(F("Failed to read Batt"));
  } else {
    Serial.print(F("VPct = ")); Serial.print(vbat); Serial.println(F("%"));
  }
}
/* END of FONA Battery Voltage Subroutine ####################################################################################################*/

/* Start of FONA Cellular Signal Strength Subroutine #########################################################################################*/
void Read_RSSI(){
  uint8_t n = fona.getRSSI();   // define and read cellular signal strength using the Adafruit_fona library
  int8_t r;     // RSSI variable
  Serial.print(F("RSSI = ")); Serial.print(n); Serial.print(": ");
  if (n == 0) r = -115;   // Convert signal status to RSSI
  if (n == 1) r = -111;
  if (n == 31) r = -52;
  if ((n >= 2) && (n <= 30)) {
    r = map(n, 2, 30, -110, -54);
  }
  Serial.print(r); Serial.println(F(" dBm"));
}
/* END of FONA Cellular Signal Strength Subroutine ###########################################################################################*/

/* Start of FONA Network Status Subroutine ##################################################################################################*/
void network_status(){
  uint8_t n = fona.getNetworkStatus();    // Define and read network status code using the Adafruit_fona library
  Serial.print(F("Network status "));
  Serial.print(n);
  Serial.print(F(": "));
  if (n == 0) Serial.println(F("Not registered"));      // Convert network status code into a narrative network status
  if (n == 1) Serial.println(F("Registered (home)"));
  if (n == 2) Serial.println(F("Not registered (searching)"));
  if (n == 3) Serial.println(F("Denied"));
  if (n == 4) Serial.println(F("Unknown"));
  if (n == 5) Serial.println(F("Registered roaming"));
}
/* END of FONA Netowrk Status Subroutine ####################################################################################################*/

/* Start of Data Upload Subroutine ##########################################################################################################*/
void Upload_Data(){
  wdt_reset();    // Reset watchdog timer

  // Power on FONA shield via key pin
  digitalWrite(FONA_key, LOW);
  delay(2000);
  digitalWrite(FONA_key, HIGH);

  wdt_reset();    // Reset watchdog timer
  wdt_disable();  // Disable watchdog timer due to long timeout requirements for Adafruit_fona library functions

  // Initialize FONA shield after power is enabled
  fonaSerial->begin(4800);
  if (! fona.begin(*fonaSerial)) {
    Serial.println(F("Couldn't find FONA"));
    return;
  }

  // Read FONA type/model/version to check FONA response
  type = fona.type();
  Serial.println(F("FONA is OK"));
  Serial.print(F("Found "));
  switch (type) {
    case FONA800L:
      Serial.println(F("FONA 800L")); break;
    case FONA800H:
      Serial.println(F("FONA 800H")); break;
    case FONA808_V1:
      Serial.println(F("FONA 808 (v1)")); break;
    case FONA808_V2:
      Serial.println(F("FONA 808 (v2)")); break;
    case FONA3G_A:
      Serial.println(F("FONA 3G (American)")); break;
    case FONA3G_E:
      Serial.println(F("FONA 3G (European)")); break;
    default: 
      Serial.println(F("???")); break;
  }
  
  // Print module IMEI number to check SIM functionality
  char imei[16] = {0}; // MUST use a 16 character buffer for IMEI!
  uint8_t imeiLen = fona.getIMEI(imei);
  if (imeiLen > 0) {
    Serial.print("Module IMEI: "); Serial.println(imei);
  }

  // Print signal stength (RSSI) for debugging purposes
  Serial.println("Reading FONA signal strength...");
  Read_RSSI();
  
  delay(10000); // Give FONA time to search for network

  // Print FONA network status for debugging purposes
  Serial.println("Reading FONA network status...");
  network_status();
  
  // Enable GPRS for data upload
  if (!fona.enableGPRS(true))
    Serial.println(F("GPRS already on"));

  // Get GSMLOC for network location information (requires GPRS)
  uint16_t returncode;
  if (!fona.getGSMLoc(&returncode, replybuffer, 250))
    Serial.println(F("Failed to get location!"));
  if (returncode == 0) {
    Serial.println(replybuffer); //break;  //break added
  } else {
    Serial.print(F("Fail code #")); Serial.println(returncode);
  }
  delay(500);
  
  // Enable HTTPS redirect functionality to upload data to HTTPS sites
  fona.setHTTPSRedirect(true);

  // Read website URL
  urldata += String(Write_API_Key);   // Inputs unique Write API Key provided by ThingSpeak, this is specific to each channel!!!
  urldata += String("&field1="); urldata += String(rtd_data);   // Sets logged temperature data for upload to field #1 on ThingSpeak channel
  urldata += String("&field2="); urldata += String(ph_data);    // Sets logged pH data for upload to field #2 on ThingSpeak channel
  urldata += String("&field3="); urldata += String(ec);         // Sets logged conductivity data for upload to field # 3 on ThingSpeak channel
  urldata += String("&field4="); urldata += String(do_mg);      // Sets logged dissolved oxygen data for upload to field # 4 on ThingSpeak channel
  urldata += String("&field5="); urldata += String(mv);         // Sets logged external battery voltage reading for upload to field # 5 on ThingSpeak channel
  urldata += String("&created_at=") + String(nextlog.year(), DEC) + String("/") + String(nextlog.month(), DEC) + String("/") + String(nextlog.day(), DEC);    // Sets date of measurement
  urldata += String("T") + String(nextlog.hour(), DEC) + String(":") + String(nextlog.minute(), DEC) + String(":") + String(nextlog.second(), DEC);           // Sets timestamp of measurement
  urldata += String("&timezone=America/New_York");    // Sets the timezone of timestamp on ThingSpeak
  if(debug){Serial.println(urldata);
    delay(500);}
  urldata.toCharArray(url, urldata.length()+1);   // Convert URL string into a character array for upload
  if(debug){Serial.println(url);                  // Print URL and character array length to serial monitoring during debugging mode
    Serial.print(F("url length is: "));
    Serial.println(urldata.length()+1);
    delay(200);}

  // Upload data to ThingSpeak using HTTP_GET method in Adafruit_fona library
  Serial.println(F("****"));
  if (!fona.HTTP_GET_start(url, &statuscode, (uint16_t *)&length)) {
    Serial.println("Failed!");
    fonaRTN = 1;
    uploadFailed++;   // Data upload failure counter
    if(debug){Serial.print("Attempt # ");Serial.println(uploadFailed);delay(200);}    // Print upload failure attempt in debugging mode
  }
  delay(500);

  // Read website response from data upload
  while (length > 0) {
    while (fona.available()) {
      char c = fona.read();
      Serial.write(c);
      length--;
      if (! length) break;
    }
  }

  urldata = "https://api.thingspeak.com/update?api_key=";   // Reset URL string for next upload sequence
  if(debug){Serial.println(urldata);delay(200);}
  
  delay(500);

  // End HTTP_Get method
  Serial.println(F("\n****"));
  fona.HTTP_GET_end();
  
  // Disable GPRS until next upload sequence
  if (!fona.enableGPRS(false)) {
    Serial.println(F("Failed to turn off GPRS"));
  }
  
  delay(1000);
  if(debug){Serial.println("Data Upload Complete...");delay(200);}

  wdt_enable(WDTO_8S);    // Reenable watchdog timer as security reset
  wdt_reset();            // Reset watchdog timer

  // Power down FONA shield using key pin
  digitalWrite(FONA_key, LOW);
  delay(2000);
  digitalWrite(FONA_key, HIGH);
  delay(200);
  if(debug){Serial.println("FONA Powering Down...");delay(200);}

  // Get current time from Real Time Clock
  rtc.begin();
  tyme = rtc.now();
  if(debug){Serial.println(tyme.year(), DEC);delay(200);}
  
  wdt_reset();            // reset watchdog timer
}
/* END of Data Upload Subroutine ##############################################################################################################*/

/* Start of Data Logging Subroutine ###########################################################################################################*/
void logmode(){

  wdt_reset();    // Reset watchdog timer
  
  // Power on Tentacle shield and open I2C wires
  digitalWrite(Atlas_pin, HIGH);
  digitalWrite(SDA_pin, HIGH);
  digitalWrite(SCL_pin, HIGH);
  delay(1000);

  wdt_reset();    // Reset watchdog timer
  
  // Put unused circuits back into sleep mode upon power up to conserve power and reduce current draw
  Wire.beginTransmission(pHaddress);    // Call I2C address for pH circuit
  Wire.write("Sleep");                  // Put pH circuit into sleep mode
  Wire.endTransmission();               //end the I2C data transmission
  delay(500);
  Wire.beginTransmission(ecaddress);    // Call I2C address for conductivity circuit
  Wire.write("Sleep");                  // Put conductivity circuit into sleep mode
  Wire.endTransmission();               //end the I2C data transmission
  delay(500);
  Wire.beginTransmission(doaddress);    // Call I2C address for dissolved oxygen circuit
  Wire.write("Sleep");                  // Put dissolved oxygen circuit into sleep mode
  Wire.endTransmission();               //end the I2C data transmission
  delay(500);

  wdt_reset();    // Reset watchdog timer
  
  // Beginning of Temperature measurement 
  Wire.beginTransmission(rtdaddress);    // Call I2C address for temperature circuit
  Wire.write("R");                       // Request a measurement from the temperature probe
  Wire.endTransmission();                // End the I2C data transmission 
  delay(1200);                           // Wait required time for circuit to process request
  if(debug){Serial.println("read temp");delay(200);}  // Print action to serial monitor for debugging purposes

  wdt_reset();    // Reset watchdog timer            
       
  Wire.requestFrom(rtdaddress,20,1);    // Call the temperature circuit and request 20 bytes
  code=Wire.read();                     // Read the first byte which is the response code separately 
  delay(200);
  if(debug){Serial.println("return temp"); delay(200);}   // Print to serial monitor for debugging purposes   

  // Read available bytes and store in a character array
  while(Wire.available()){        
    in_char = Wire.read();          
    rtd_data[i]= in_char;             
    i+=1;                           
      if(in_char==0){                 
          i=0;                        
          Wire.endTransmission();     
          break;                      
      }
    }
  delay(200);

  wdt_reset();    // Reset watchdog timer

  Wire.beginTransmission(rtdaddress);   // Call I2C address for temperature circuit
  Wire.write("Sleep");                  // Set temperature circuit to sleep mode
  Wire.endTransmission();               // End I2C transmission
  delay(500);
  if(debug){Serial.println("temp sleep");delay(200);}   // Print to serial monitor in debug mode

  wdt_reset();    // Reset watchdog timer
 
  // END of Temperature measurement
    
  // Beginning of PH measurement
  
  Wire.beginTransmission(pHaddress);      // Call I2C address for pH circuit
  Wire.write("T,");                       // Issue command for temperature compensation
  Wire.write(rtd_data);                   // Input most recent temperature reading for temperature compensation of pH
  Wire.endTransmission();                 // End the I2C transmission
  delay(500);                             // Wait required time for circuit to process command
  if(debug){Serial.println("pH/temp comp");delay(200);}  // Print to serial monitor in debug mode

  wdt_reset();   // Reset watchdog timer

  // Read response from temperature compensation
  Wire.requestFrom(pHaddress,20,1);      // Call the pH circuit and request 20 bytes
  code=Wire.read();                      // Read the first byte which is the response code separately  
  delay(200);
  Wire.beginTransmission(pHaddress);     // Call I2C address of pH circuit
  Wire.write("R");                       // Request a measurement from the pH probe
  Wire.endTransmission();                // End I2C transmission
  delay(1200);                           // Wait required amount of time to process request
  if(debug){Serial.println("pH read");delay(200);}    // Print to serial monitor in debug mode

  wdt_reset();    // Reset watchdog timer

  // Read response code and pH data from circuit   
  Wire.requestFrom(pHaddress,20,1);      // Call the pH circuit and request 20 bytes
  code=Wire.read();                      // Read the first byte which is the response code separately 
  delay(200);
  if(debug){Serial.println("return pH");delay(200);}    // Print to the serial monitor in debug mode
  
  // Read available bytes and store in a character array
  while(Wire.available()){            
  in_char = Wire.read();           
  ph_data[i]= in_char;             
  i+=1;                            
   if(in_char==0){                 
       i=0;                       
       Wire.endTransmission();     
       break;                     
  }
 }
 delay(200); 
 
 Wire.beginTransmission(pHaddress);    // Call I2C address for pH circuit
 Wire.write("Sleep");                  // Set pH circuit to sleep mode
 Wire.endTransmission();               // End I2C transmission
 delay(500);

 // END of pH measurement
    
 if(debug){Serial.println("pH sleep");delay(200);}   // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 // Beginning of conductivity measurement

 Wire.beginTransmission(ecaddress);    // Call I2C address of conductivity circuit
 Wire.write("T,");                     // Issue command for temperature compensation
 Wire.write(rtd_data);                 // Input most recent temperature reading for temperature compensation
 Wire.endTransmission();               // End I2C transmission
 delay(500);                           // Wait required amount of time for circuit to process request
 if(debug){Serial.println("ec/temp comp");delay(200);}    // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 // Read response from temperature compensation
 Wire.requestFrom(ecaddress,48,1);      // Call the conductivity circuit and request 48 bytes
 code=Wire.read();                      // Read the first byte which is the response code separately
 delay(200);  
 
 Wire.beginTransmission(ecaddress);     // Call I2C address for conductivity circuit
 Wire.write("R");                       // Request a measurement from conductivity probe
 Wire.endTransmission();                // End I2C transmission
 delay(1400);                           // Wait required amount of time for circuit to process request
 if(debug){Serial.println("ec read");delay(200);}   // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 Wire.requestFrom(ecaddress,48,1);      // Call conductivity circuit and request 48 bytes
 code=Wire.read();                      // Read the first byte which is the response code separately
 delay(300);
 if(debug){Serial.println("ec return");delay(200);}   // Print to serial monitor in debug mode

 // Read available bytes and store in a character array
 while(Wire.available()){            
 in_char = Wire.read();          
 ec_data[i]= in_char;             
 i+=1;                            
  if(in_char==0){                 
    i=0;                       
    Wire.endTransmission();    
    break;                     
  }
 }
 delay(1000);

 Wire.beginTransmission(ecaddress);     // Call I2C address of conductivity circuit
 Wire.write("Sleep");                   // Set conductivity circuit to sleep mode
 Wire.endTransmission();                // End I2C transmission
 delay(500);

 wdt_reset();   // Reset watchdog timer

 // Parse conductivity and salinity data
 ec = strtok(ec_data, ",");               // Parse the string at each comma
 sal = strtok(NULL, ",");                 // Parse the string at each comma

 if(debug){Serial.println("ec parsed and sleep");delay(200);}   // Print to serial monitor in debug mode

 // END of Conductivity measurement

 wdt_reset();   // Reset watchdog timer

 // Beginning of Dissolved Oxygen measurement

 Wire.beginTransmission(doaddress);     // Call I2C address of DO circuit
 Wire.write("T,");                      // Issue command for temperature compensation
 Wire.write(rtd_data);                  // Input most recent temperature measurement for temperature compensation
 Wire.endTransmission();                // End I2C transmission
 delay(500);                            // Wait required amount of time to process request
 if(debug){Serial.println("do/temp comp");delay(200);}    // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 // Read response code from temperature compensation
 Wire.requestFrom(doaddress,48,1);      // Call DO circuit and request 48 bytes
 code=Wire.read();                      // Read the first byte which is the response code separately
 delay(300);

 Wire.beginTransmission(doaddress);     // Call the I2C address of DO circuit  
 Wire.write("S,");                      // Issue command for salinity compensation        
 Wire.write(sal);                       // Input most recent salinity measurement for salinity compensation
 Wire.endTransmission();                // End I2C transmission 
 delay(500);                            // Wait required amount of time to process request
 if(debug){Serial.println("do/sal comp");delay(200);}   // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 // Read response code from salinity compensation
 Wire.requestFrom(doaddress,48,1);      // Call DO circuit and request 48 bytes
 code=Wire.read();                      // Read the first byte which is the response code separately
 delay(300);
 
 Wire.beginTransmission(doaddress);     // Call I2C address for DO circuit
 Wire.write("R");                       // Request a measurement from the DO probe
 Wire.endTransmission();                // End I2C transmission
 delay(1400);                           // Wait the required amount of time to process request
 if(debug){Serial.println("do read");delay(200);}   // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 Wire.requestFrom(doaddress,48,1);      // Call DO circuit and request 48 bytes
 code=Wire.read();                      // Read first byte which is the response code separately
 delay(300);
 if(debug){Serial.println("do return");delay(200);}   // Print to serial monitor in debug mode

 // Read available bytes and store in a character array
 while(Wire.available()){         
 in_char = Wire.read();        
 do_data[i]= in_char;             
 i+=1;                           
  if(in_char==0){             
    i=0;                        
    Wire.endTransmission();     
    break;                     
  }
 }
 delay(1000);

 Wire.beginTransmission(doaddress);       // Call I2C address of DO circuit
 Wire.write("Sleep");                     // Set DO circuit to sleep mode
 Wire.endTransmission();                  // End I2C transmission
 delay(500);

 do_mg = strtok(do_data, ",");            // Parse the string at each comma.
 do_per = strtok(NULL, ",");              // Parse the string at each comma.

 if(debug){Serial.println("do parsed and sleep");delay(200);}   // Print to serial monitor in debug mode

 wdt_reset();   // Reset watchdog timer

 // End of Dissolved Oxygen measurement

 // Read External Battery Voltage

 batt_read = analogRead(batt_pin);          // Read external battery level on analog pin
 mv = (ADC_AREF/1023.0)*batt_read*1000.0;   // Convert to battery voltage in milli Volts


 if(debug){   // Print header and timestamp to serial monitor in debug mode
  Serial.println("Date[y/m/d],Time[h:m:s],Temp[deg.C],pH[S.U.],SpCond[uS/cm],DO[mg/L],DO[%Sat],Bat[mv]");
  // Print timestamp to serial monitor
  Serial.println();
  Serial.print(nextlog.year(), DEC);
  Serial.print('/');
  if(nextlog.month() < 10){
    Serial.print('0');
    Serial.print(nextlog.month(), DEC);}
  else {Serial.print(nextlog.month(), DEC);}
  Serial.print('/');
  if (nextlog.day() < 10){
    Serial.print('0');
    Serial.print(nextlog.day(), DEC);}    
  else {Serial.print(nextlog.day(), DEC);}
  Serial.print(',');
  if (nextlog.hour() < 10){  
    Serial.print('0');
    Serial.print(nextlog.hour(), DEC);}
  else {Serial.print(nextlog.hour(), DEC);} 
  Serial.print(':');
  if (nextlog.minute() < 10){
    Serial.print('0');
    Serial.print(nextlog.minute(), DEC);}
  else {Serial.print(nextlog.minute(), DEC);}
  Serial.print(':');
  if (nextlog.second() < 10){
    Serial.print('0');
    Serial.print(nextlog.second(), DEC);}
  else {Serial.print(nextlog.second(), DEC);} // end of current time display}
  delay(500);
 }

 wdt_reset();    // Reset watchdog timer

 // Log timestamp to data file
 //dataFile.println();
 dataFile.print(nextlog.year(), DEC);
 dataFile.print('/');
 if(nextlog.month() < 10){
  dataFile.print('0');
  dataFile.print(nextlog.month(), DEC);}
 else {dataFile.print(nextlog.month(), DEC);}
 dataFile.print('/');
 if (nextlog.day() < 10){
  dataFile.print('0');
  dataFile.print(nextlog.day(), DEC);}    
 else {dataFile.print(nextlog.day(), DEC);}
 dataFile.print(',');
 if (nextlog.hour() < 10){  
  dataFile.print('0');
  dataFile.print(nextlog.hour(), DEC);}
 else {dataFile.print(nextlog.hour(), DEC);} 
 dataFile.print(':');
 if (nextlog.minute() < 10){
  dataFile.print('0');
  dataFile.print(nextlog.minute(), DEC);}
 else {dataFile.print(nextlog.minute(), DEC);}
 dataFile.print(':');
 if (nextlog.second() < 10){
  dataFile.print('0');
  dataFile.print(nextlog.second(), DEC);}
 else {dataFile.print(nextlog.second(), DEC);} // end of current time display
 delay(500);

 wdt_reset();   // Reset watchdog timer

 if(debug){   // Print data to serial monitor in debug mode
  Serial.print(", ");
  Serial.print(rtd_data); 
  Serial.print(", ");
  Serial.print(ph_data);     
  Serial.print(", ");
  Serial.print(ec);
  Serial.print(", ");
  Serial.print(do_mg);
  Serial.print(", ");
  Serial.print(do_per);
  Serial.print(", ");
  Serial.println(mv);
  delay(500);
 }

 wdt_reset();   // Reset watchdog timer

 // Log to SD card
 dataFile.print(',');
 dataFile.print(rtd_data); 
 dataFile.print(',');
 dataFile.print(ph_data);     
 dataFile.print(',');
 dataFile.print(ec);
 dataFile.print(',');
 dataFile.print(do_mg);
 dataFile.print(',');
 dataFile.print(do_per);
 dataFile.print(',');
 dataFile.println(mv);

 dataFile.flush();    // Flush data to SD card
 delay(5000);         // Give time to write

 wdt_reset();   // Reset watchdog timer

 // Begin reat time clock and read current time
 rtc.begin();                                                         // Start the real time clock
 tyme = rtc.now();                                                    // Recall time from the real time clock
 nextlog = tyme.unixtime()/Sample_incr*Sample_incr+Sample_incr;       // Rounds next log time off to an even time
 delay(200);

 // Power down Tentacle shield and switch off I2C wires
 digitalWrite(SDA_pin, LOW);
 digitalWrite(SCL_pin, LOW);
 delay(200);
 digitalWrite(Atlas_pin, LOW);
 delay(1000);

 wdt_reset();   // Reset watchdog timer
}
/* END of Data Logging Subroutine ########################################################################################################*/

/* Start Watchdog Interrupt Configuration Subroutine #####################################################################################*/
void wdt_setup_interrupt() {  // Setup watchdog timer as 8 second interrupt from sleep cycle
  wdt_reset();
  cli();  // Disable interrupts
  MCUSR &= ~(1<<WDRF);  // Set watchdog timer reset bit for MCU to zero
  WDTCSR |= (1<<WDCE) | (1<<WDE); //  Enter watchdog configuration mode
  WDTCSR = (1<<WDIE) | (0<<WDE) | (1<<WDP3) | (1<<WDP0);  //  Set watchdog timer settings as interrupt enabled/reset disabled for 8000ms cycle (from Atmel2560 manual)
  sei();  //  Enable Interrupts
  wdt_reset();
}
/* END Watchdog Interrupt Configuration Subroutine #########################################################################################*/

/* Start Watchdog Reset Configuration Subroutine ###########################################################################################*/
void wdt_setup_reset() {  //  Setup watchdog timer as 8 second security reset for sensor hangups
  wdt_reset();
  cli();  //  Disable interrupts
  MCUSR &= ~(1<<WDRF);  //  Set watchdog timer reset bit for MCU to zero
  WDTCSR |= (1<<WDCE) | (1<<WDE); //  Enter watchdog configuration mode
  WDTCSR = (0<<WDIE) | (1<<WDE) | (1<<WDP3) | (0<<WDP2) | (0<<WDP1) | (1<<WDP0);  //  Set watchdog timer settings as interrupt disabled/reset enabled for 8000ms cycle (from Atmel2560 manual)
  sei();  //  Enable interrupts
  wdt_reset();
}
/* END Watchdog Reset Configuration Subroutine #############################################################################################*/

// END OF SKETCH #############################################################################################################################

/* ********************************************************************************************************************************************
 * Sensors:
 *    - Atlas Scientific water quality probes (pH, PT-1000 Thermistor, Conductivity K1.0, and Dissolved Oxygen)
 *    - pH, Conductivity, RTD, and Dissolved Oxygen EZO circuits
 *    - Tentacle Shield from Whitebox Labs configured for I2C protocol 
 * 
 * Microcontroller:
 *    - Arduino Mega 2560 Rev 3
 *    
 * Cellular Telemtry:
 *    - FONA808 Shield with stackable headers
 *    - FONA Key pin wired to pin 24 on Mega to toggle modem power
 *    - Tx is wired to pin 10 on FONA shield
 *    
 * Datalogger:
 *    - Adafruit Datalogger Shield for Arduino with stackable headers
 *    - Chip Select pin on Datalogger Shield is wired to pin 34 on Mega
 *    
 * Power Management:
 *    - Tentacle shield is NOT stacked on Mega. This shield is isolated due to high power consumption.
 *    - Power to the Tentacle shield is toggled ON/OFF by the addition of a NPN-type 2N4401 Transistor and CD4066B Quad Bilateral (DIP14) Switch
 *      mounted to protospace on datalogger shield. 
 *    - Transistor is wired in line with the ground from Mega to the Tentacle shield. A 2.2kOhm resistor is 
 *      wired to base drive on transistor and is controlled by pin 44 on Mega. 
 *    - The CD4066B is used to Toggle ON/OFF the SDA and SCL wires for I2C communications with the Tentacle Shield and stop the leaking of current to the
 *      Tentacle shield during power down/sleep mode. Logic pins for both SDA and SCL are connected and wired to pin 39 on Mega.
 *      
 * External Power:
 *    - Sensor circuitry is powered by a 3.7V LiPo battery connected by the Adafruit USB/DC Solar Charger circuit and a 6V 6W solar panel. 
 *    - Battery output is boosted by a 5V PowerBoost from Adafruit and supplies power to Arduino via USB port.
 *    - Te positive battery pin on the 5V Powerboost is wired to A5 on the Mega for monitoring the external battery voltage.    
 * ***************************************************************************************************************************************************/
